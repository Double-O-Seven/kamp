package ch.leadrian.samp.kamp.codegen.cpp

import ch.leadrian.samp.cidl.model.Function
import ch.leadrian.samp.cidl.model.Types
import ch.leadrian.samp.kamp.codegen.SingleFileCodeGenerator
import ch.leadrian.samp.kamp.codegen.camelCaseName
import ch.leadrian.samp.kamp.codegen.hasNoImplementation
import ch.leadrian.samp.kamp.codegen.isNative
import ch.leadrian.samp.kamp.codegen.isOutParameter
import java.io.File
import java.io.Writer

internal class SAMPNativeFunctionsCppGenerator(
        private val functions: List<Function>,
        private val javaPackageName: String,
        outputDirectory: File
) : SingleFileCodeGenerator(outputDirectory) {

    override val fileName: String = "SAMPNativeFunctions.cpp"

    override fun generate(writer: Writer) {
        writer.writeHeader()
        writer.writeFunctions(functions)
    }

    private fun Writer.writeHeader() {
        write(
                """
            |
            |/* Do not edit this file, it is generated */
            |
            |#include <cstring>
            |
            |#include <sampgdk/a_actor.h>
            |#include <sampgdk/a_objects.h>
            |#include <sampgdk/a_players.h>
            |#include <sampgdk/a_samp.h>
            |#include <sampgdk/a_vehicles.h>
            |#include <sampgdk/core.h>
            |#include <sampgdk/sdk.h>
            |
            |#include "SAMPNativeFunctions.h"
            |
            |#include "Kamp.hpp"
            |#include "FieldCache.hpp"
            |
            |
        """.trimMargin("|")
        )
    }

    private fun Writer.writeFunctions(functions: List<Function>) {
        functions
                .filter { it.isNative && !it.hasNoImplementation }
                .forEach { writeFunction(it) }
    }

    private fun Writer.writeFunction(function: Function) {
        writeFunctionSignature(function)
        write(" {\n")
        writeFunctionBody(function)
        write("}\n\n")
    }

    private fun Writer.writeFunctionSignature(function: Function) {
        val returnType = getJniType(function.type)
        val packagePart = javaPackageName.replace('.', '_')
        write("JNIEXPORT $returnType JNICALL Java_${packagePart}_SAMPNativeFunctions_${function.camelCaseName}\n        (")
        writeFunctionParameters(function)
        write(")")
    }

    private fun Writer.writeFunctionParameters(function: Function) {
        write("JNIEnv *env, jclass clazz")
        function.parameters.forEach {
            val parameterJavaType = when {
                it.isOutParameter -> getJniOutType(it.type)
                else -> getJniType(it.type)
            }
            write(", $parameterJavaType ${it.name}")
        }
    }

    private fun Writer.writeFunctionBody(function: Function) {
        val methodParameterGenerators: List<MethodParameterGenerator> = getMethodParameterGenerators(function)

        methodParameterGenerators.mapNotNull { it.generateMethodCallSetup() }.forEach { write(it) }

        val resultProcessingSteps = methodParameterGenerators.asReversed()
                .mapNotNull { it.generateMethodCallResultProcessing() }

        when {
            resultProcessingSteps.isEmpty() && function.type != Types.VOID -> write("    return ")
            function.type != Types.VOID -> write("    auto _result = ")
        }
        write("${function.name}(")
        write(methodParameterGenerators.joinToString(separator = ", ") { it.generateMethodInvocationParameter() })
        write(");\n")

        resultProcessingSteps.forEach { write(it) }

        if (resultProcessingSteps.isNotEmpty() && function.type != Types.VOID) {
            write("    return _result;\n")
        }
    }

    private fun getMethodParameterGenerators(function: Function): List<MethodParameterGenerator> {
        val methodParameterGenerators: MutableList<MethodParameterGenerator> = mutableListOf()
        var skipNextParameter = false
        val indentation = "    "

        for ((index, parameter) in function.parameters.withIndex()) {
            if (skipNextParameter) {
                skipNextParameter = false
                continue
            }

            methodParameterGenerators += when {
                parameter.type == Types.FLOAT && parameter.isOutParameter ->
                    ReferenceFloatMethodParameterGenerator(
                            parameterName = parameter.name,
                            indentation = indentation
                    )
                parameter.type == Types.INT && parameter.isOutParameter ->
                    ReferenceIntMethodParameterGenerator(
                            parameterName = parameter.name,
                            indentation = indentation
                    )
                parameter.type == Types.STRING && parameter.isOutParameter -> {
                    skipNextParameter = true
                    val sizeParameterName = function.parameters[index + 1].name
                    ReferenceStringMethodParameterGenerator(
                            parameterName = parameter.name,
                            sizeParameterName = sizeParameterName,
                            indentation = indentation
                    )
                }
                parameter.type == Types.STRING ->
                    ConstCharMethodParameterGenerator(
                            parameterName = parameter.name,
                            indentation = indentation
                    )
                parameter.type == Types.BOOL -> JbooleanMethodParameterGenerator(parameter.name)
                else -> DefaultMethodParameterGenerator(parameter.name)
            }
        }
        return methodParameterGenerators
    }

}