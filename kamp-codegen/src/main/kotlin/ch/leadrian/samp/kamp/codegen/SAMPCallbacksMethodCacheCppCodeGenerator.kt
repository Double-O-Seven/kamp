package ch.leadrian.samp.kamp.codegen

import ch.leadrian.samp.cidl.model.Function
import ch.leadrian.samp.cidl.parser.InterfaceDefinitionParser
import java.io.BufferedWriter
import java.nio.file.Files
import java.nio.file.Path
import java.nio.file.StandardOpenOption

class SAMPCallbacksMethodCacheCppCodeGenerator {

    fun generate(outputDirectory: Path, functions: List<Function>, fileName: String = "SAMPCallbacksMethodCache") {
        Files.createDirectories(outputDirectory)
        val outputFile = outputDirectory.resolve("$fileName.cpp")

        Files.newBufferedWriter(outputFile, StandardOpenOption.CREATE, StandardOpenOption.WRITE).use { writer ->
            writeHeader(writer, fileName)
            writeMethodIDInitializations(functions, writer)
            writeFooter(writer)
        }
    }

    private fun writeHeader(writer: BufferedWriter, className: String) {
        writer.write("""
            |
            |/* Do not edit this file, it is generated */
            |
            |#include <jni.h>
            |
            |#include "$className.hpp"
            |
            |int $className::Initialize(JNIEnv *jniEnv, jclass clazz) {
            |    this->onProcessTickMethodID = jniEnv->GetMethodID(clazz, "onProcessTick", "()V");
            |    if (this->onProcessTickMethodID == nullptr) {
            |        return -1;
            |    }
            |
            |""".trimMargin("|"))
    }

    private fun writeMethodIDInitializations(functions: List<Function>, writer: BufferedWriter) {
        functions
                .filter { it.hasAttribute("callback") }
                .forEachIndexed { index, function ->
                    val errorValue = -(index + 2)
                    writeMethodIDInitialization(function, errorValue, writer)
                }
    }

    private fun writeMethodIDInitialization(function: Function, errorValue: Int, writer: BufferedWriter) {
        val camelCaseName = "${function.name[0].toLowerCase()}${function.name.substring(1)}"
        val methodSignature = getCallbackMethodSignature(function)
        writer.write("""
            |    this->${camelCaseName}MethodID = jniEnv->GetMethodID(clazz, "$camelCaseName", "$methodSignature");
            |    if (this->${camelCaseName}MethodID == nullptr) {
            |        return $errorValue;
            |    }
            |
            |
        """.trimMargin())
    }

    private fun getCallbackMethodSignature(function: Function): String {
        val parameterSignature = function.parameters.joinToString(separator = "") { getJvmTypeSignature(it.type) }
        return "(" + parameterSignature + ")" + getJvmTypeSignature(function.type)
    }

    private fun writeFooter(writer: BufferedWriter) {
        writer.write("    return 0;\n}\n")
        writer.close()
    }

    companion object {

        @JvmStatic
        fun main(args: Array<String>) {
            val codeGeneratorArguments = CodeGeneratorArguments.parse(args = args, packageNameRequired = false)
            val interfaceDefinitionParser = InterfaceDefinitionParser()
            val functions = interfaceDefinitionParser.parse(*codeGeneratorArguments.interfaceDefinitionSources).functions
            SAMPCallbacksMethodCacheCppCodeGenerator().generate(
                    outputDirectory = codeGeneratorArguments.outputDirectoryPath,
                    functions = functions
            )
        }
    }

}